{

  "spherical-impostor.f": "float distanceFromCenter = length(impostorSpaceCoordinate);\nif(distanceFromCenter >= uRadius ) {\n     discard;\n}\n\nfloat far=gl_DepthRange.far;\nfloat near=gl_DepthRange.near;\nfloat normalizedDepth = sqrt(uRadius * uRadius\n          - distanceFromCenter * distanceFromCenter);\nfloat depthOfFragment = fDepth + normalizedDepth * (fSphereRadiusDepth);\ngl_FragDepthEXT = (((far-near) * depthOfFragment) + near + far) / 2.0;\n\nvec3 transformedNormal = vec3(impostorSpaceCoordinate, normalizedDepth);\n\nvec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz - vec3(0., 0., - depthOfFragment);\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvec3 lightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\nvec3 lightBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\n#if NUM_POINT_LIGHTS > 0\n\nfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n     getPointDirectLight( pointLights[ i ], geometry, directLight );\n\n     dotNL = dot( geometry.normal, directLight.direction );\n     directLightColor_Diffuse = PI * directLight.color;\n\n     lightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n#ifdef DOUBLE_SIDED\n\n     lightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n#endif\n\n}\n\n#endif\n\n#if NUM_SPOT_LIGHTS > 0\n\nfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n     getSpotDirectLight( spotLights[ i ], geometry, directLight );\n\n     dotNL = dot( geometry.normal, directLight.direction );\n     directLightColor_Diffuse = PI * directLight.color;\n\n     lightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n#ifdef DOUBLE_SIDED\n\n     lightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n#endif\n}\n\n#endif\n\n#if NUM_DIR_LIGHTS > 0\n\nfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n     getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\n     dotNL = dot( geometry.normal, directLight.direction );\n     directLightColor_Diffuse = PI * directLight.color;\n\n     lightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n#ifdef DOUBLE_SIDED\n\n     lightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n#endif\n\n}\n\n#endif\n\n#if NUM_HEMI_LIGHTS > 0\n\nfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n     lightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n#ifdef DOUBLE_SIDED\n\n     lightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\n#endif\n\n}\n\n#endif\n\n",

  "spherical-impostor.fh": "#extension GL_EXT_frag_depth : enable\n\nuniform mediump float uRadius;\n\nvarying mediump vec2 impostorSpaceCoordinate;\nvarying mediump vec3 normalizedViewCoordinate;\nvarying mediump vec4 mvPosition;\nvarying highp float fDepth;\nvarying highp float fSphereRadiusDepth;\n",

  "spherical-impostor.v": "impostorSpaceCoordinate = position.xy;\nmvPosition = (modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)\n              + vec4( position.x, position.y, 0.0, 0.0));\ngl_Position = projectionMatrix * mvPosition;\n\nfDepth = gl_Position.z / gl_Position.w;\nvec4 vRayDir = vec4(position - cameraPosition, 0.0);\nfloat fLength = length(vRayDir);\nvRayDir = normalize(vRayDir);\nfLength = fLength + uRadius;\nvec4 oSphereEdgePos = vec4(cameraPosition, 0.0) + (fLength * vRayDir);\noSphereEdgePos.w = 1.0;\noSphereEdgePos = projectionMatrix * modelViewMatrix * oSphereEdgePos;\n\nfloat fSphereEdgeDepth = oSphereEdgePos.z / oSphereEdgePos.w;\nfSphereRadiusDepth = fDepth - fSphereEdgeDepth;\n",

  "spherical-impostor.vh": "uniform mediump mat4 orthographicMatrix;\nuniform mediump float uRadius;\n\nattribute vec3 center;\nattribute vec4 inputImpostorSpaceCoordinate;\n\nvarying mediump vec2 impostorSpaceCoordinate;\nvarying mediump vec3 normalizedViewCoordinate;\nvarying mediump vec4 mvPosition;\nvarying highp float fDepth;\nvarying highp float fSphereRadiusDepth;\n"

}
